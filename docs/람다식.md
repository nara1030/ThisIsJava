람다식
=====
## 목차
1. [기본](#기본)
	* [필요성](#필요성)
	* [개념](#개념)
	* [문법](#문법)
2. 응용
3. 참고

## 기본

### 필요성
* 함수적 프로그래밍이 부각되고 있는 두 가지 이유
	* 병렬 처리
	* 이벤트 지향 프로그래밍
* 따라서 객체지향과 함수형을 혼합하는 식으로 개발 트렌드가 변화
	* 자바는 함수적 프로그래밍을 위해 자바 8부터 람다식 지원
	* 자바에서 람다식을 수용한 두 가지 이유
		* 자바 코드가 간결해짐
		* `컬렉션의 요소를` 필터링하거나 매핑해서 원하는 결과를 쉽게 집계 가능

##### [목차로 이동](#목차)

### 개념
* 람다식은 익명 함수(anonymous function)를 생성하기 위한 식
	* 람다식의 형태는 매개변수를 가진 코드 블록이지만, 런타임 시에는 인터페이스의 익명 구현 객체를 생성함
		* 람다식 → 매개 변수를 가진 코드 블록 → 익명 구현 객체
	* 예를 들어 Runnable 인터페이스
		* 람다식  
			```java
			Runnable runnable = () -> { ... };
			```
		* 익명 구현 객체  
			```java
			Runnable runnable = new Runnable() {
				public void run() { ... }
			};
			```
	* 어떤 인터페이스를 구현할 것인가는 대입되는 인터페이스에 달려 있음
		* 위 코드는 Runnable 변수에 대입되므로 람다식은 Runnable의 익명 구현 객체를 생성

**좀 더 개념적으로 들어가보면**

* 타겟 타입(target type)이란
	* 람다식이 대입될 인터페이스를 지칭
		* 람다식은 인터페이스 변수에 대입  
			`인터페이스 변수 = 람다식;`
	* 람다식은 대입될 인터페이스의 종류에 따라 작성 방법이 달라짐
		* 즉 람다식은 인터페이스의 익명 구현 객체를 생성한다는 의미
		* 인터페이스는 직접 객체화할 수 없기 때문에 구현 클래스가 필요한데 람다식은 익명 구현 클래스를 생성하고 객체화 함
	* 람다식은 그 생김새와는 달리 단순히 메소드를 선언하는 것이 아니라 메소드를 갖고 있는 객체를 생성
		* 자바는 클래스의 구성 멤버로 메소드를 선언함을 상기

* 함수적 인터페이스(@FunctionalInterface)란
	* 람다식의 타겟 타입이 될 수 있는 하나의 추상 메소드가 선언된 인터페이스를 지칭
		* 람다식이 하나의 메소드를 정의하기 때문에 두 개 이상의 추상 메소드가 선언된 인터페이스는 람다식을 이용해서 구현 객체를 생성할 수 없음
		* 즉 모든 인터페이스를 람다식의 타겟 타입으로 사용할 수는 없음
	* @FunctionalInterface
		* 함수적 인터페이스를 작성할 때 두 개 이상의 추상 메소드가 선언되지 않도록 컴파일러가 체킹해주는 기능
		* 인터페이스 선언 시 @FunctionalInterface 어노테이션을 붙이면 두 개 이상의 추상 메소드 선언 시 컴파일 오류를 발생시킴
		* 이는 선택사항으로 붙이지 않더라도 하나의 추상 메소드만 있다면 모두 함수적 인터페이스지만 붙이는 걸 권장

##### [목차로 이동](#목차)

### 문법
* 함수적 스타일의 람다식 작성하는 방법  
	* (타입 매개변수, ...) -> { 실행문; ... }
	* 예시  
		```java
		// 매개변수가 있는 경우
		(int a) -> { System.out.println(a); }
		(a) -> { System.out.println(a); }
		a -> System.out.println(a)
		(x, y) -> { return x + y; };
		(x, y) -> x + y
		```
	* 매개변수 타입은 런타임 시에 대입되는 값에 따라 자동으로 인식될 수 있기 때문에 람다식에서는 매개 변수의 타입을 일반적으로 언급하지 않음

##### [목차로 이동](#목차)

## 응용

##### [목차로 이동](#목차)

## 참고

##### [목차로 이동](#목차)