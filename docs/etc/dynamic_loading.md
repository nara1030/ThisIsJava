동적인 클래스 로딩(dynamic loading)
=====
지금껏 다형성과 같은 의미로 오해하고 있어서 조금씩 기록해보려고 한다.
- - -
## 목차
1. [개념](#개념)
	* [배경](#배경)
		* [바이트 코드](#바이트-코드)
	* [동적 클래스 로딩](#동적-클래스-로딩)
		* [클래스 로더](#클래스-로더)
2. [연관](#연관)
3. [출처](#출처)

## 개념
### 배경
자바 코드 실행 단계를 간단히 컴파일, 실행의 두 단계로 생각했는데 상세히 살펴볼 필요가 있다.

* 실행 파일 생성 과정(`javac ***.java`)
	* `전처리(Pre-processing)`
		* 주석 제거 및 인라인화
		* 자바의 경우, 주석 유지
	* `컴파일(Compiling)`
		* 일반적으로 소스 코드를 기계가 인식할 수 있는 네이티브 코드로 변환하는 과정 의미
		* 자바의 경우, 소스 코드를 JVM이 인식할 수 있는 [바이트 코드](#바이트-코드)(.class)로 변환하는 것 의미
	* `어셈블리(Assembly)`
		* 기계어 코드로 변환
		* 자바의 경우, 이 (프로그램 실행 전에 네이티브 기계어 코드를 만들어내는) 단계 없음
	* `링크(Linking)`
		* 기계어 코드와 라이브러리 코드를 합쳐 최종 실행 파일 생성
		* 자바의 경우, 이 단계는 (JVM에 의해) 프로그램 실행 시 동적으로 수행
* 실행(`java ***`)
	* JRE(Java Runtime Environment) 시작
		* `java` 명령어의 인자로 지정된 클래스를 실행하기 위한 자바 실행 환경 조성
	* 클래스(`main()` 포함) 로딩
		* ????
	* `main()` 메소드 호출

##### [목차로 이동](#목차)

#### 바이트 코드
자바 컴파일은 아래 두 과정이다.

* 자바 코드를 자바 언어 스펙에 따라 분석/검증
* 이후 JVM 스펙의 class 파일 구조에 맞는 바이트 코드 생성

컴파일의 결과인 바이트 코드(.class)는 총 세 부분으로 구성된다.

* 클래스 메타 정보
* 상수 풀(클래스 단위)
	* 소스 코드에서 정적으로 파악할 수 있는 변수, 상수, 메소드 등 정보
* 코드 구현부(JVM 명령어 + 오퍼랜드)
	* JVM 명령어와 상수 풀에 저장된 항목을 오퍼랜드로 사용하는 연산, 제어, 메소드 호출 등

##### [목차로 이동](#목차)

### 동적 클래스 로딩
자바는 동적으로 클래스를 읽어온다. 즉, 런타임에 모든 코드가 JVM에 링크된다. 모든 클래스는 그 클래스가 참조되는 순간에 동적으로 JVM에 링크되며, 메모리에 로딩된다(즉, 실행 시 모든 클래스 파일들이 한 번에 JVM 메모리에 로딩되지 않고 요청되는 순간에 로딩된다). 이러한 동적인 클래스 로딩은 자바의 클래스로더 시스템을 통해서 이루어지며, 자바가 기본적으로 제공하는 [클래스로더](#클래스-로더)는 `java.lang.ClassLoader`를 통해서 표현된다.

런타임에 동적으로 클래스를 로딩한다는 것은 JVM이 클래스에 대한 정보를 갖고 있지 않다는 것을 의미한다. 따라서 클래스로더는 클래스를 로딩할 때 필요한 정보를 구하고, 그 클래스가 올바른지 검사할 수 있어야 한다. JVM은 내부적으로 클래스를 분석할 수 있는 기능을 갖고 있으며, JDK 1.1부터는 개발자들이 [리플렉션](https://github.com/nara1030/ThisIsJava/blob/master/docs/etc/polymorphism.md)(Reflection)을 통해서 이러한 클래스의 분석을 할 수 있도록 하고 있다.

클래스를 로딩하는 방식에는 두 가지가 있다.

* 로드타임 동적 로딩(`load-time dynamic loading`)
	* .
* 런타임 동적 로딩(`run-time dynamic loading`)
	* .

##### [목차로 이동](#목차)

#### 클래스 로더
클래스 로더가 요청 시 클래스를 JVM으로 로딩하는 역할을 수행한다. 이는 자바 런타임 환경(JRE)의 일부이다.

자바의 클래스 로딩은 세부적으로 세 단계를 거친다.

* 로딩
	* 바이트 코드(.class)를 읽어 메모리(JVM)로 가져오는 과정
* 링크(검증/준비/로딩)
	* 읽어온 바이트 코드가 자바 규칙을 따르는지 검증
	* 클래스에 정의된 필드, 메소드, 인터페이스의 데이터 구조 준비
	* 위 클래스가 참조하는 다른 클래스 로딩
* 초기화
	* 슈퍼 클래스 및 정적 필드 초기화

클래스 로딩은 클래스를 로딩하는 시점 또는 실행 중간에도 할 수 있다(두 가지 로딩 방식). 클래스 로더는 `classpath`라는 환경 변수에 등록된 디렉토리에 있는 클래스를 먼저 JVM에 로딩한다. 이렇게 JVM에 로딩된 클래스만을 객체로 사용할 수 있다.
	
##### [목차로 이동](#목차)

## 연관


##### [목차로 이동](#목차)

## 출처
* 자바 - 컴파일에서 실행까지
	* [컴파일에서 실행까지 - (1)](https://homoefficio.github.io/2019/01/31/Back-to-the-Essence-Java-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EC%97%90%EC%84%9C-%EC%8B%A4%ED%96%89%EA%B9%8C%EC%A7%80-1/)
	* [자바 - 컴파일에서 실행까지 - (2)](https://homoefficio.github.io/2019/01/31/Back-to-the-Essence-Java-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EC%97%90%EC%84%9C-%EC%8B%A4%ED%96%89%EA%B9%8C%EC%A7%80-2/)
* 클래스 로더
	* [동적인 클래스 로딩과 클래스 로더](https://javacan.tistory.com/entry/1)
	* [클래스 로더 - JDK2](https://javacan.tistory.com/entry/2)
	* [클래스 로더 훑어보기](https://homoefficio.github.io/2018/10/13/Java-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A1%9C%EB%8D%94-%ED%9B%91%EC%96%B4%EB%B3%B4%EA%B8%B0/)
* 자바 - 동적 로딩
	* [동적 로딩 이해(위임 모델)](https://futurists.tistory.com/43)
	
##### [목차로 이동](#목차)