연산자
====

## 목차
1. [연산자와 연산식](#연산자와-연산식)
2. [연산의 방향과 우선순위](#연산의-방향과-우선순위)
3. [단항 연산자](#단항-연산자)
4. [이항 연산자](#이항-연산자)
5. [삼항 연산자](#삼항-연산자)

## 연산자와 연산식
+ 연산(operations): 프로그램에서 데이터를 처리하여 결과를 산출하는 것
+ 연산자(operator): 연산에 사용되는 표시나 기호
+ 피연산자(operand): 연산되는 데이터
+ 연산식(expressions): 연산자와 피연산자를 이용하여 연산의 과정을 기술한 것

> 연산식
>> 연산식(연산자)은 반드시 하나의 값을 산출  
>> 따라서 값 대신 연산식 사용 가능  

```java
short s = 100;
short result = -s; // 컴파일 에러
```

> 부호 연산자의 산출 타입은 int 타입이므로 컴파일 에러 발생(자동 타입 변환 불가)
>> 연산자를 사용할 때 주의할 점은 산출 타입이 있다는 것  
>> 정수 타입 연산의 결과가 int 타입인 이유는 JVM이 32비트 단위로 계산하기 때문  

+ 자바에서의 기본 타입
	+ 정수 연산: int  
	+ 실수 연산: double  

```java
char c1 = 'A' + 1;
char c2 = 'A';
// char c3 = c2 + 1; // 컴파일 에러
```

> 예외 케이스
>> 자바는 리터럴 간의 연산은 타입 변환 없이 해당 타입으로 계산되기 때문에 첫 번째 라인은 문제 없음  
>> 그러나 3번째 라인은 c2가 int 타입으로 변환된 후 1과 연산되므로 산출 타입은 int 타입이 됨  

```java
int x = 1000000;
int y = 1000000;
long z = x * y;
```

> 위 소스의 경우도 같은 이유로 컴파일 에러가 발생  
> 올바른 값을 얻기 위해선 변수 x와 y 중 최소 하나라도 long 타입이 되어야 함  

+ 주의사항
	+ 정확한 계산이 필요한 경우 실수 타입 사용 불가

### cf. 메서드
+ 왜 사용해야 하는가?
	+ 피연산자의 값을 직접 리터럴로 주는 경우는 드뭄
	+ 대부분 사용자로부터 입력 혹은 런타임 시 동적 생성됨
	+ 이런 경우 산술 연산자(+, -, \*, /)보다 메서드 이용
	+ 연산 전 피연산자들의 값을 조사해 오버플로우 탐지 가능

## 연산의 방향과 우선순위
> 대부분의 연산자는 왼쪽에서부터 오른쪽으로(→) 연산  
> 하지만 단항 연산자, 부호 연산자, 대입 연산자는 오른쪽에서 왼쪽으로(←) 연산  

### 구분
| 구분 | 연산자 | 피연산자 | 연산 방향 | 우선순위 |
| :--: | :-- | :-- | :-----: | :----: |
| 단항 연산자 | ++, --, +, -, ~, ! | | ◀ | |
| 산술 연산자 | \*, /, % </br> +, - | boolean 타입 제외 모든 기본 타입 | ▶ | |
| 비교 이동 연산자 | <<, >>, >>> | | ▶ | |
| 비교 연산자 | <, >, instanceof ▶ ==, != | 대소 연산자의 경우 boolean 타입 제외 모든 기본 타입 | ▶ | |
| 비트 (혹은 논리) 연산자 | &, \|, ^ | | ▶ | |
| 논리 연산자 | &&, \|\|, ^ | | ▶ | |
| 대입 연산자 | =, +=, ^=, >>= | | ◀ | |  

> 비트 논리 연산자(&, |, ^)  
>> 피연산자가 boolean 타입일 경우: 일반 논리 연산자  
>> 피연산자가 정수 타입일 경우: 비트 논리 연산자  

> 비트 논리 연산자(&, |, ^, ~)
>> 비트 연산자는 데이터를 비트 단위로 연산하므로 0과 1로 표현 가능한 정수 타입만 연산 가능  
>> 비트 연산자는 피연산자를 INT 타입으로 자동 변환한 후 연산 수행  

> NOT(논리부정): 피연산자의 논리값을 바꿈  
>> 논리 연산자: !  
>> 비트 논리 연산자(보수): ~  

## 단항 연산자

## 이항 연산자

## 삼항 연산자
